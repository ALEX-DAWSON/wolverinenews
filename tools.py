#!/usr/bin/env python3

import os
import glob
import time
import shutil
import itertools

from jinja2 import BaseLoader
from jinja2 import Environment

import htmlmin
import yaml
import mistune 
import frontmatter
from termcolor import colored


class GlobLoader(BaseLoader):
    '''
    Uses glob from standard library to load files. Paths can be excluded by
    prepending an exclamation mark. Path expansion with ** works in Python 3.5+
    '''

    def __init__(self, paths):
        '''
        paths must be a list
        '''
        files = [self.concat_paths(item) for item in paths]
        self.files = list(itertools.chain.from_iterable(files))

    @classmethod
    def concat_paths(cls, paths_to_concat):
        '''
        Concatenates paths from lists or named individually, and sorts
        them into positive and negative match lists
        '''
        positive_match = []
        negative_match = []
        if isinstance(paths_to_concat, list):
            for item in paths_to_concat:
                cls.append_path_to_list(item, positive_match, negative_match)
        elif isinstance(paths_to_concat, str):
            cls.append_path_to_list(paths_to_concat,
                                    positive_match,
                                    negative_match)
        return list(set(positive_match) - set(negative_match))

    @staticmethod
    def append_path_to_list(path_to_append, positive_match, negative_match):
        '''
        Sorts paths into positive and negative matches with correct path names
        '''
        if path_to_append.startswith('!'):
            negative_match += glob.glob(path_to_append[1:])
        else:
            positive_match += glob.glob(path_to_append)

    def get_source(self, environment, template):
        for item in self.files:
            if os.path.basename(item) == template:
                mtime = os.path.getmtime(item)
                with open(item, 'r') as f:
                    return (f.read(),
                            item,
                            lambda: mtime == os.path.getmtime(item))


def clean(path):
    '''Delete files generated by build script'''
    for root, dirs, files in os.walk(path):
        for f in files:
            os.unlink(os.path.join(root, f))
        for d in dirs:
            if os.path.islink(os.path.join(root, d)):
                os.unlink(os.path.join(root, d))
            else:
                shutil.rmtree(os.path.join(root, d))



def markdown_filter(text):
    renderer = mistune.Renderer(parse_html=True)
    markdown = mistune.Markdown(renderer=renderer)
    return markdown(text)


def get_destination(page, dest, production):
    '''
    Joins dest to the last part of the path from page, and strips the
    file extension
    '''
    basename = os.path.basename(page)
    if production:
        final_name = os.path.splitext(basename)[0]
    else:
        final_name = f'{os.path.splitext(basename)[0]}.html'
    return os.path.join(dest, final_name)


def get_section_pages(path, dest, production):
    section_pages = []
    source_pages = glob.glob(os.path.join(path,'*')) 

    for page_name in source_pages:
        page = {'src': page_name}
        set_page_metadata(page)
        page['data']['dest'] = get_destination(page_name, dest, production)

        section_pages.append(page['data'])
                     
    section_pages = sorted(section_pages, key=lambda x: x['order'])
    section_pages.reverse()
    return section_pages 


def set_page_metadata(page, index=False):
    '''
    Sets metadata, including dest, content, data
    '''
    if page['src'].endswith('.yaml'):
        with open(page['src'], 'r') as f:
            page['data'] = yaml.load(f)
        page['src'] = f'{page["src"][:-4]}html'

    elif page['src'].endswith('.md') or page['src'].endswith('.html'):
        fm_page = frontmatter.load(page['src'])
        page['data'] = fm_page.metadata
        if not index:
            page['content'] = fm_page.content
    else:
        print(f"{page['src']} must be in either .yaml,"
                ' .md or .html (jinja2) format!')


def get_pages(files, production):
    '''
    Returns a list containing one or more dicts of page data
    '''
    if isinstance(files, dict):
        files = [files]

    pages = []
    for fileset in files:
        current_filenames = GlobLoader.concat_paths(fileset['src'])

        for filename in current_filenames:
            page = ({'src': filename, 
                     'dest': get_destination(filename,
                                             fileset['dest'], 
                                             production),
                     'template': fileset['template']})

            section_pages = []
            if ('options' in fileset and 'section pages' in fileset['options']):
                section_pages = get_section_pages(
                                 fileset['options']['section pages'],
                                 fileset['options']['section pages prefix'],
                                 production)

            set_page_metadata(page, production)
            if section_pages is not None:
                page['data']['section_pages'] = section_pages

            pages.append(page)
            
    return pages


def build_pageset(pageset, options, production=False, s3=None):
    '''Logic for building pages.'''

    template_files = [pageset[pathset] for pathset in pageset
                      if pathset in ['partials', 'layouts']]
    j2_env = Environment(loader=GlobLoader(template_files), trim_blocks=True)
    j2_env.filters['markdown'] = markdown_filter
    pages = get_pages(pageset['files'], production)
    for page in pages:
        f_id = os.path.splitext(os.path.basename(page['src']))[0]
        page['data']['id'] = f_id 
        t1 = time.time()
        print(f'Building {page["src"]}...', end='')
        if 'content' in page:
            final_page = j2_env.from_string(page['content']
                            ).render(page['data'])
        else:
            template = j2_env.get_template(page['template'])
            final_page = template.render(page['data']) 

        # UPDATE HTML TIDY BEFORE UNCOMMENTING
        # tidy_page, errors = tidy_document(final_page)
        # if errors:
        #     error_page = os.path.basename(page['src'])
        #     with open('HTMLTidy Errors', 'a') as f:
        #         f.write('{0}:\n{1}'.format(error_page, errors))

        print(f' Done writing {page["dest"]} in '
              f'{round(float(time.time() - t1), 4)} seconds')

        if production:
            final_page = htmlmin.minify(final_page)
            print(f'Sending {page["dest"]}...', end='')
            s3.Object(options['s3 bucket'], destination
                    ).put(Body=final_page, ContentType='text/html')
            print('  done!')
        else:
            local_path = os.path.join(options['prod'],
                                      os.path.dirname(page['dest']))
            os.makedirs(local_path, exist_ok=True)
            with open(os.path.join(options['prod'],
                                   page['dest']), 'w') as f:
                f.write(final_page)


def move_static(static_dir, s3, s3_bucket_name, local_static):
    for item in glob.glob('{0}/**/*'.format(static_dir), recursive=True):
        if os.path.isfile(item):
            print('Moving {0}'.format(item))
            content_type = None
            if item.endswith('.js'):
                content_type = 'application/javascript'
            elif item.endswith('.css'):
                content_type = 'text/css'
            s3.Object(s3_bucket_name, os.path.relpath(item,
                local_static)).put(Body=open(item, 'rb'),
                                   ContentType=content_type)


def main(pagesets, options, s3, production=False):
    # if os.path.isfile('HTMLTidy Errors'):
    #     os.unlink('HTMLTidy Errors')
    t0 = time.time()

    # # All # #
    for pageset in pagesets:
        build_pageset(pageset, options, production=production, s3=s3)
    print(f'Built all pages in {round(float(time.time() - t0), 4)} seconds')

    # if os.path.isfile('HTMLTidy Errors'):
    #     print(colored(' '.join(['HTML Errors Detected!',
    #                             'Check HTMLTidy Errors for details']),
    #                   'red'))


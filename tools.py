#!/usr/bin/env python3

import os
import glob
import time
import shutil
import itertools

from jinja2 import BaseLoader
from jinja2 import Environment

import htmlmin
import yaml
import mistune 
import frontmatter
from tidylib import tidy_document
from termcolor import colored


class GlobLoader(BaseLoader):
    '''
    Uses glob from standard library to load files. Paths can be excluded by
    prepending an exclamation mark. Path expansion with ** works in Python 3.5+
    '''

    def __init__(self, paths):
        '''
        paths must be a list
        '''
        files = [self.concat_paths(item) for item in paths]
        self.files = list(itertools.chain.from_iterable(files))

    @classmethod
    def concat_paths(cls, paths_to_concat):
        '''
        Concatenates paths from lists or named individually, and sorts
        them into positive and negative match lists
        '''
        positive_match = []
        negative_match = []
        if isinstance(paths_to_concat, list):
            for item in paths_to_concat:
                cls.append_path_to_list(item, positive_match, negative_match)
        elif isinstance(paths_to_concat, str):
            cls.append_path_to_list(paths_to_concat,
                                    positive_match,
                                    negative_match)
        return list(set(positive_match) - set(negative_match))

    @staticmethod
    def append_path_to_list(path_to_append, positive_match, negative_match):
        '''
        Sorts paths into positive and negative matches with correct path names
        '''
        if path_to_append.startswith('!'):
            negative_match += glob.glob(path_to_append[1:])
        else:
            positive_match += glob.glob(path_to_append)

    def get_source(self, environment, template):
        for item in self.files:
            if os.path.basename(item) == template:
                mtime = os.path.getmtime(item)
                with open(item, 'r') as f:
                    return (f.read(),
                            item,
                            lambda: mtime == os.path.getmtime(item))


def clean():
    '''Delete files generated by build script'''
    # clean dist
    for root, dirs, files in os.walk('dist'):
        for f in files:
            os.unlink(os.path.join(root, f))
        for d in dirs:
            shutil.rmtree(os.path.join(root, d))

    if os.path.isfile('HTMLTidy Errors'):
        os.unlink('HTMLTidy Errors')


def markdown_filter(text):
    renderer = mistune.Renderer(parse_html=True)
    markdown = mistune.Markdown(renderer=renderer)
    return markdown(text)


def get_destination(page, dest, production):
    '''
    Joins dest to the last part of the path from page, and strips the
    file extension
    '''
    basename = os.path.basename(page)
    if production:
        final_name = os.path.splitext(basename)[0]
    else:
        final_name = basename
    return os.path.join(dest, final_name)


def get_sidebar_data(pages):
    sidebar_data = []
    for page in pages:
        f_id = os.path.splitext(os.path.basename(page['src']))[0]
        sidebar_data.append({'title': page['data']['title'],
                             'id': f_id, 
                             'order': page['data']['order']})
    return sorted(sidebar_data, key=lambda x: x['order'])


def set_page_metadata(pages, production):
    '''
    Sets metadata, including src, dest, content, data
    '''
    for page in pages:

        if page['src'].endswith('.yaml'):
            with open(page['src'], 'r') as f:
                page['data'] = yaml.load(f)
            page['src'] = '{0}html'.format(page['src'][:-4])

        elif page['src'].endswith('.md') or page['src'].endswith('.html'):
            fm_page = frontmatter.load(page['src'])
            page['data'] = fm_page.metadata
            page['content'] = fm_page.content
            if page['src'].endswith('.md'):
                page['src'] = '{0}html'.format(page['src'][:-2])
        else:
            print(' '.join(['{0} must be in either'.format(page['src']),
                            '.yaml, .md or .html (jinja2) format!']))


def get_pages(files):
    '''
    Returns a list containing one or more dicts of page data
    '''
    if isinstance(files, dict):
        files = [files]
    pages = []
    for fileset in files:
        current_filenames = GlobLoader.concat_paths(fileset['src'])
        for filename in current_filenames:
            pages.append({'src': filename, 'dest': fileset['dest'],
                          'content': '', 'data': ''})
    return pages


def build_pageset(pageset, options, production=False, s3=None):
    '''Logic for building pages.'''

    template_files = [pageset[pathset] for pathset in pageset
                      if pathset in ['partials', 'layouts']]
    j2_env = Environment(loader=GlobLoader(template_files), trim_blocks=True)
    j2_env.filters['markdown'] = markdown_filter
    pages = get_pages(pageset['files'])
    set_page_metadata(pages, production)

    # need a copy to embed to avoid circular reference, sorting it for sidebar
    sidebar_data = []
    if ('section' in pageset['options'] and
            pageset['options']['section'] is True):
        sidebar_data = get_sidebar_data(pages)

    for page in pages:
        f_id = os.path.splitext(os.path.basename(page['src']))[0]
        page['data']['id'] = f_id 
        if sidebar_data:
            page['data']['pages'] = sidebar_data
        t1 = time.time()
        print('Building {0}...'.format(page['src']), end='')
        if page['content']:
            final_page = j2_env.from_string(page['content']).render(page['data'])
        else:
            template = j2_env.get_template(pageset['options']['template'])
            final_page = template.render(page['data']) 

        # UPDATE HTML TIDY BEFORE UNCOMMENTING
        # tidy_page, errors = tidy_document(final_page)
        # if errors:
        #     error_page = os.path.basename(page['src'])
        #     with open('HTMLTidy Errors', 'a') as f:
        #         f.write('{0}:\n{1}'.format(error_page, errors))

        print(' Done in {0} seconds'.format(round(float(time.time() - t1), 4)))

        destination = get_destination(page['src'],
                                      page['dest'],
                                      production)
        if production:
            final_page = htmlmin.minify(final_page)
            print('Sending {0}...'.format(destination), end='')
            s3.Object(options['s3 bucket'],
                      destination).put(Body=final_page,
                                       ContentType='text/html')
            print('  done!')
        else:
            local_path = os.path.join(options['local prefix'],
                                      os.path.split(destination)[0])
            os.makedirs(local_path, exist_ok=True)
            with open(os.path.join(options['local prefix'],
                                   destination), 'w') as f:
                f.write(final_page)


def move_static(static_dir, s3, s3_bucket_name, local_static):
    for item in glob.glob('{0}/**/*'.format(static_dir), recursive=True):
        if os.path.isfile(item):
            print('Moving {0}'.format(item))
            content_type = None
            if item.endswith('.js'):
                content_type = 'application/javascript'
            elif item.endswith('.css'):
                content_type = 'text/css'
            s3.Object(s3_bucket_name, os.path.relpath(item,
                local_static)).put(Body=open(item, 'rb'),
                                   ContentType=content_type)


def main(pagesets, options, s3, production=False):
    t0 = time.time()

    # # All # #
    for pageset in pagesets:
        build_pageset(pageset, options, production=production, s3=s3)
    print('Built all pages in {0} seconds'.format(
        round(float(time.time() - t0), 4)))

    # if os.path.isfile('HTMLTidy Errors'):
    #     print(colored(' '.join(['HTML Errors Detected!',
    #                             'Check HTMLTidy Errors for details']),
    #                   'red'))
